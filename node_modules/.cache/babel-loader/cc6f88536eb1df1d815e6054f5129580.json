{"ast":null,"code":"/* global _WORKLET */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport { Easing } from './Easing';\nimport { isColor, convertToHSVA, toRGBA } from './Colors';\nimport NativeReanimated from './NativeReanimated';\nlet IN_STYLE_UPDATER = false;\nexport function initialUpdaterRun(updater) {\n  IN_STYLE_UPDATER = true;\n  const result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\nexport function transform(value, handler) {\n  'worklet';\n\n  if (value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === 'string') {\n    // toInt\n    // TODO handle color\n    const match = value.match(/([A-Za-z]*)(-?\\d*\\.?\\d*)([A-Za-z%]*)/);\n    const prefix = match[1];\n    const suffix = match[3];\n    const number = match[2];\n    handler.__prefix = prefix;\n    handler.__suffix = suffix;\n    return parseFloat(number);\n  } // toString if __prefix is available and number otherwise\n\n\n  if (handler.__prefix === undefined) {\n    return value;\n  }\n\n  return handler.__prefix + value + handler.__suffix;\n}\nexport function transformAnimation(animation) {\n  'worklet';\n\n  if (!animation) {\n    return;\n  }\n\n  animation.toValue = transform(animation.toValue, animation);\n  animation.current = transform(animation.current, animation);\n  animation.startValue = transform(animation.startValue, animation);\n}\nexport function decorateAnimation(animation) {\n  'worklet';\n\n  if (animation.isHigherOrder) {\n    return;\n  }\n\n  const baseOnStart = animation.onStart;\n  const baseOnFrame = animation.onFrame;\n  const animationCopy = Object.assign({}, animation);\n  delete animationCopy.callback;\n\n  const prefNumberSuffOnStart = (animation, value, timestamp, previousAnimation) => {\n    const val = transform(value, animation);\n    transformAnimation(animation);\n    if (previousAnimation !== animation) transformAnimation(previousAnimation);\n    baseOnStart(animation, val, timestamp, previousAnimation);\n    transformAnimation(animation);\n    if (previousAnimation !== animation) transformAnimation(previousAnimation);\n  };\n\n  const prefNumberSuffOnFrame = (animation, timestamp) => {\n    transformAnimation(animation);\n    const res = baseOnFrame(animation, timestamp);\n    transformAnimation(animation);\n    return res;\n  };\n\n  const tab = ['H', 'S', 'V', 'A'];\n\n  const colorOnStart = (animation, value, timestamp, previousAnimation) => {\n    let HSVAValue;\n    let HSVACurrent;\n    let HSVAToValue;\n    const res = [];\n\n    if (isColor(value)) {\n      HSVACurrent = convertToHSVA(animation.current);\n      HSVAValue = convertToHSVA(value);\n\n      if (animation.toValue) {\n        HSVAToValue = convertToHSVA(animation.toValue);\n      }\n    }\n\n    tab.forEach((i, index) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = HSVACurrent[index];\n      animation[i].toValue = HSVAToValue ? HSVAToValue[index] : undefined;\n      animation[i].onStart(animation[i], HSVAValue[index], timestamp, previousAnimation ? previousAnimation[i] : undefined);\n      res.push(animation[i].current);\n    });\n    animation.current = toRGBA(res);\n  };\n\n  const colorOnFrame = (animation, timestamp) => {\n    const HSVACurrent = convertToHSVA(animation.current);\n    const res = [];\n    let finished = true;\n    tab.forEach((i, index) => {\n      animation[i].current = HSVACurrent[index];\n      finished &= animation[i].onFrame(animation[i], timestamp);\n      res.push(animation[i].current);\n    });\n    animation.current = toRGBA(res);\n    return finished;\n  };\n\n  animation.onStart = (animation, value, timestamp, previousAnimation) => {\n    if (isColor(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    }\n\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\nexport function defineAnimation(starting, factory) {\n  'worklet';\n\n  if (IN_STYLE_UPDATER) {\n    return starting;\n  }\n\n  const create = () => {\n    'worklet';\n\n    const animation = factory();\n    decorateAnimation(animation);\n    return animation;\n  };\n\n  if (_WORKLET || !NativeReanimated.native) {\n    return create();\n  }\n\n  return create;\n}\nexport function cancelAnimation(sharedValue) {\n  'worklet'; // setting the current value cancels the animation if one is currently running\n\n  sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign\n}\nexport function withTiming(toValue, userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(toValue, () => {\n    'worklet';\n\n    const config = {\n      duration: 300,\n      easing: Easing.inOut(Easing.quad)\n    };\n\n    if (userConfig) {\n      Object.keys(userConfig).forEach(key => config[key] = userConfig[key]);\n    }\n\n    function timing(animation, now) {\n      const {\n        toValue,\n        progress,\n        startTime,\n        current\n      } = animation;\n      const runtime = now - startTime;\n\n      if (runtime >= config.duration) {\n        // reset startTime to avoid reusing finished animation config in `start` method\n        animation.startTime = 0;\n        animation.current = toValue;\n        return true;\n      }\n\n      const newProgress = config.easing(runtime / config.duration);\n      const dist = (toValue - current) * (newProgress - progress) / (1 - progress);\n      animation.current += dist;\n      animation.progress = newProgress;\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      if (previousAnimation && previousAnimation.type === 'timing' && previousAnimation.toValue === toValue && previousAnimation.startTime) {\n        // to maintain continuity of timing animations we check if we are starting\n        // new timing over the old one with the same parameters. If so, we want\n        // to copy animation timeline properties\n        animation.startTime = previousAnimation.startTime;\n        animation.progress = previousAnimation.progress;\n      } else {\n        animation.startTime = now;\n        animation.progress = 0;\n      }\n\n      animation.current = value;\n    }\n\n    return {\n      type: 'timing',\n      onFrame: timing,\n      onStart,\n      progress: 0,\n      toValue,\n      current: toValue,\n      callback\n    };\n  });\n}\nexport function withSpring(toValue, userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(toValue, () => {\n    'worklet'; // TODO: figure out why we can't use spread or Object.assign here\n    // when user config is \"frozen object\" we can't enumerate it (perhaps\n    // something is wrong with the object prototype).\n\n    const config = {\n      damping: 10,\n      mass: 1,\n      stiffness: 100,\n      overshootClamping: false,\n      restDisplacementThreshold: 0.01,\n      restSpeedThreshold: 2\n    };\n\n    if (userConfig) {\n      Object.keys(userConfig).forEach(key => config[key] = userConfig[key]);\n    }\n\n    function spring(animation, now) {\n      const {\n        toValue,\n        lastTimestamp,\n        current,\n        velocity\n      } = animation;\n      const deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n      const c = config.damping;\n      const m = config.mass;\n      const k = config.stiffness;\n      const v0 = -velocity;\n      const x0 = toValue - current;\n      const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio\n\n      const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)\n\n      const omega1 = omega0 * Math.sqrt(1 - Math.pow(zeta, 2)); // exponential decay\n\n      const t = deltaTime / 1000;\n      const sin1 = Math.sin(omega1 * t);\n      const cos1 = Math.cos(omega1 * t); // under damped\n\n      const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n      const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n      const underDampedPosition = toValue - underDampedFrag1; // This looks crazy -- it's actually just the derivative of the oscillation function\n\n      const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1); // critically damped\n\n      const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n      const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n      const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n\n      const isOvershooting = () => {\n        if (config.overshootClamping && config.stiffness !== 0) {\n          return current < toValue ? animation.current > toValue : animation.current < toValue;\n        } else {\n          return false;\n        }\n      };\n\n      const isVelocity = Math.abs(velocity) < config.restSpeedThreshold;\n      const isDisplacement = config.stiffness === 0 || Math.abs(toValue - current) < config.restDisplacementThreshold;\n\n      if (zeta < 1) {\n        animation.current = underDampedPosition;\n        animation.velocity = underDampedVelocity;\n      } else {\n        animation.current = criticallyDampedPosition;\n        animation.velocity = criticallyDampedVelocity;\n      }\n\n      if (isOvershooting() || isVelocity && isDisplacement) {\n        if (config.stiffness !== 0) {\n          animation.velocity = 0;\n          animation.current = toValue;\n        }\n\n        return true;\n      }\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.current = value;\n\n      if (previousAnimation) {\n        animation.velocity = previousAnimation.velocity || animation.velocity || 0;\n        animation.lastTimestamp = previousAnimation.lastTimestamp || now;\n      } else {\n        animation.lastTimestamp = now;\n      }\n    }\n\n    return {\n      onFrame: spring,\n      onStart,\n      toValue,\n      velocity: config.velocity || 0,\n      current: toValue,\n      callback\n    };\n  });\n}\nexport function withDecay(userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(0, () => {\n    'worklet';\n\n    const config = {\n      deceleration: 0.998\n    };\n\n    if (userConfig) {\n      Object.keys(userConfig).forEach(key => config[key] = userConfig[key]);\n    }\n\n    const VELOCITY_EPS = 5;\n\n    function decay(animation, now) {\n      const {\n        lastTimestamp,\n        initialVelocity,\n        current,\n        velocity\n      } = animation;\n      const deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n      const kv = Math.pow(config.deceleration, deltaTime);\n      const kx = config.deceleration * (1 - kv) / (1 - config.deceleration);\n      const v0 = velocity / 1000;\n      const v = v0 * kv * 1000;\n      const x = current + v0 * kx;\n      animation.current = x;\n      animation.velocity = v;\n      let toValueIsReached = null;\n\n      if (Array.isArray(config.clamp)) {\n        if (initialVelocity < 0 && animation.current <= config.clamp[0]) {\n          toValueIsReached = config.clamp[0];\n        } else if (initialVelocity > 0 && animation.current >= config.clamp[1]) {\n          toValueIsReached = config.clamp[1];\n        }\n      }\n\n      if (Math.abs(v) < VELOCITY_EPS || toValueIsReached !== null) {\n        if (toValueIsReached !== null) {\n          animation.current = toValueIsReached;\n        }\n\n        return true;\n      }\n    }\n\n    function onStart(animation, value, now) {\n      animation.current = value;\n      animation.lastTimestamp = now;\n      animation.initialVelocity = config.velocity;\n    }\n\n    return {\n      onFrame: decay,\n      onStart,\n      velocity: config.velocity || 0,\n      callback\n    };\n  });\n}\nexport function withDelay(delayMs, _nextAnimation) {\n  'worklet';\n\n  return defineAnimation(_nextAnimation, () => {\n    'worklet';\n\n    const nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function delay(animation, now) {\n      const {\n        startTime,\n        started,\n        previousAnimation\n      } = animation;\n\n      if (now - startTime > delayMs) {\n        if (!started) {\n          nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);\n          animation.previousAnimation = null;\n          animation.started = true;\n        }\n\n        const finished = nextAnimation.onFrame(nextAnimation, now);\n        animation.current = nextAnimation.current;\n        return finished;\n      } else if (previousAnimation) {\n        const finished = previousAnimation.onFrame(previousAnimation, now);\n        animation.current = previousAnimation.current;\n\n        if (finished) {\n          animation.previousAnimation = null;\n        }\n      }\n\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startTime = now;\n      animation.started = false;\n      animation.current = value;\n      animation.previousAnimation = previousAnimation;\n    }\n\n    const callback = finished => {\n      if (nextAnimation.callback) {\n        nextAnimation.callback(finished);\n      }\n    };\n\n    return {\n      isHigherOrder: true,\n      onFrame: delay,\n      onStart,\n      current: nextAnimation.current,\n      callback\n    };\n  });\n}\nexport function withSequence(..._animations) {\n  'worklet';\n\n  return defineAnimation(_animations[0], () => {\n    'worklet';\n\n    const animations = _animations.map(a => {\n      const result = typeof a === 'function' ? a() : a;\n      result.finished = false;\n      return result;\n    });\n\n    const firstAnimation = animations[0];\n\n    const callback = finished => {\n      if (finished) {\n        // we want to call the callback after every single animation\n        // not after all of them\n        return;\n      } // this is going to be called only if sequence has been cancelled\n\n\n      animations.forEach(animation => {\n        if (typeof animation.callback === 'function' && !animation.finished) {\n          animation.callback(finished);\n        }\n      });\n    };\n\n    function sequence(animation, now) {\n      const currentAnim = animations[animation.animationIndex];\n      const finished = currentAnim.onFrame(currentAnim, now);\n      animation.current = currentAnim.current;\n\n      if (finished) {\n        // we want to call the callback after every single animation\n        if (currentAnim.callback) {\n          currentAnim.callback(true\n          /* finished */\n          );\n        }\n\n        currentAnim.finished = true;\n        animation.animationIndex += 1;\n\n        if (animation.animationIndex < animations.length) {\n          const nextAnim = animations[animation.animationIndex];\n          nextAnim.onStart(nextAnim, currentAnim.current, now, currentAnim);\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      if (animations.length === 1) {\n        throw Error('withSequence() animation require more than one animation as argument');\n      }\n\n      animation.animationIndex = 0;\n\n      if (previousAnimation === undefined) {\n        previousAnimation = animations[animations.length - 1];\n      }\n\n      firstAnimation.onStart(firstAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      isHigherOrder: true,\n      onFrame: sequence,\n      onStart,\n      animationIndex: 0,\n      current: firstAnimation.current,\n      callback\n    };\n  });\n}\nexport function withRepeat(_nextAnimation, numberOfReps = 2, reverse = false, callback) {\n  'worklet';\n\n  return defineAnimation(_nextAnimation, () => {\n    'worklet';\n\n    const nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function repeat(animation, now) {\n      const finished = nextAnimation.onFrame(nextAnimation, now);\n      animation.current = nextAnimation.current;\n\n      if (finished) {\n        animation.reps += 1; // call inner animation's callback on every repetition\n        // as the second argument the animation's current value is passed\n\n        if (nextAnimation.callback) {\n          nextAnimation.callback(true\n          /* finished */\n          , animation.current);\n        }\n\n        if (numberOfReps > 0 && animation.reps >= numberOfReps) {\n          return true;\n        }\n\n        const startValue = reverse ? nextAnimation.current : animation.startValue;\n\n        if (reverse) {\n          nextAnimation.toValue = animation.startValue;\n          animation.startValue = startValue;\n        }\n\n        nextAnimation.onStart(nextAnimation, startValue, now, nextAnimation.previousAnimation);\n        return false;\n      }\n\n      return false;\n    }\n\n    const repCallback = finished => {\n      if (callback) {\n        callback(finished);\n      } // when cancelled call inner animation's callback\n\n\n      if (!finished && nextAnimation.callback) {\n        nextAnimation.callback(false\n        /* finished */\n        );\n      }\n    };\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startValue = value;\n      animation.reps = 0;\n      nextAnimation.onStart(nextAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      isHigherOrder: true,\n      onFrame: repeat,\n      onStart,\n      reps: 0,\n      current: nextAnimation.current,\n      callback: repCallback\n    };\n  });\n}\n/* Deprecated section, kept for backward compatibility. Will be removed soon */\n\nexport function delay(delayMs, _nextAnimation) {\n  'worklet';\n\n  console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\n  return withDelay(delayMs, _nextAnimation);\n}\nexport function repeat(_nextAnimation, numberOfReps = 2, reverse = false, callback) {\n  'worklet';\n\n  console.warn('Method `repeat` is deprecated. Please use `withRepeat` instead');\n  return withRepeat(_nextAnimation, numberOfReps, reverse, callback);\n}\nexport function loop(nextAnimation, numberOfLoops = 1) {\n  'worklet';\n\n  console.warn('Method `loop` is deprecated. Please use `withRepeat` instead');\n  return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);\n}\nexport function sequence(..._animations) {\n  'worklet';\n\n  console.warn('Method `sequence` is deprecated. Please use `withSequence` instead');\n  return withSequence(..._animations);\n}\n/* Deprecated section end */","map":{"version":3,"sources":["/Users/hello/node_modules/react-native-reanimated/lib/reanimated2/animations.js"],"names":["Easing","isColor","convertToHSVA","toRGBA","NativeReanimated","IN_STYLE_UPDATER","initialUpdaterRun","updater","result","transform","value","handler","undefined","match","prefix","suffix","number","__prefix","__suffix","parseFloat","transformAnimation","animation","toValue","current","startValue","decorateAnimation","isHigherOrder","baseOnStart","onStart","baseOnFrame","onFrame","animationCopy","Object","assign","callback","prefNumberSuffOnStart","timestamp","previousAnimation","val","prefNumberSuffOnFrame","res","tab","colorOnStart","HSVAValue","HSVACurrent","HSVAToValue","forEach","i","index","push","colorOnFrame","finished","defineAnimation","starting","factory","create","_WORKLET","native","cancelAnimation","sharedValue","withTiming","userConfig","config","duration","easing","inOut","quad","keys","key","timing","now","progress","startTime","runtime","newProgress","dist","type","withSpring","damping","mass","stiffness","overshootClamping","restDisplacementThreshold","restSpeedThreshold","spring","lastTimestamp","velocity","deltaTime","Math","min","c","m","k","v0","x0","zeta","sqrt","omega0","omega1","pow","t","sin1","sin","cos1","cos","underDampedEnvelope","exp","underDampedFrag1","underDampedPosition","underDampedVelocity","criticallyDampedEnvelope","criticallyDampedPosition","criticallyDampedVelocity","isOvershooting","isVelocity","abs","isDisplacement","withDecay","deceleration","VELOCITY_EPS","decay","initialVelocity","kv","kx","v","x","toValueIsReached","Array","isArray","clamp","withDelay","delayMs","_nextAnimation","nextAnimation","delay","started","withSequence","_animations","animations","map","a","firstAnimation","sequence","currentAnim","animationIndex","length","nextAnim","Error","withRepeat","numberOfReps","reverse","repeat","reps","repCallback","console","warn","loop","numberOfLoops","round"],"mappings":"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","sourcesContent":["/* global _WORKLET */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport { Easing } from './Easing';\nimport { isColor, convertToHSVA, toRGBA } from './Colors';\nimport NativeReanimated from './NativeReanimated';\nlet IN_STYLE_UPDATER = false;\nexport function initialUpdaterRun(updater) {\n    IN_STYLE_UPDATER = true;\n    const result = updater();\n    IN_STYLE_UPDATER = false;\n    return result;\n}\nexport function transform(value, handler) {\n    'worklet';\n    if (value === undefined) {\n        return undefined;\n    }\n    if (typeof value === 'string') {\n        // toInt\n        // TODO handle color\n        const match = value.match(/([A-Za-z]*)(-?\\d*\\.?\\d*)([A-Za-z%]*)/);\n        const prefix = match[1];\n        const suffix = match[3];\n        const number = match[2];\n        handler.__prefix = prefix;\n        handler.__suffix = suffix;\n        return parseFloat(number);\n    }\n    // toString if __prefix is available and number otherwise\n    if (handler.__prefix === undefined) {\n        return value;\n    }\n    return handler.__prefix + value + handler.__suffix;\n}\nexport function transformAnimation(animation) {\n    'worklet';\n    if (!animation) {\n        return;\n    }\n    animation.toValue = transform(animation.toValue, animation);\n    animation.current = transform(animation.current, animation);\n    animation.startValue = transform(animation.startValue, animation);\n}\nexport function decorateAnimation(animation) {\n    'worklet';\n    if (animation.isHigherOrder) {\n        return;\n    }\n    const baseOnStart = animation.onStart;\n    const baseOnFrame = animation.onFrame;\n    const animationCopy = Object.assign({}, animation);\n    delete animationCopy.callback;\n    const prefNumberSuffOnStart = (animation, value, timestamp, previousAnimation) => {\n        const val = transform(value, animation);\n        transformAnimation(animation);\n        if (previousAnimation !== animation)\n            transformAnimation(previousAnimation);\n        baseOnStart(animation, val, timestamp, previousAnimation);\n        transformAnimation(animation);\n        if (previousAnimation !== animation)\n            transformAnimation(previousAnimation);\n    };\n    const prefNumberSuffOnFrame = (animation, timestamp) => {\n        transformAnimation(animation);\n        const res = baseOnFrame(animation, timestamp);\n        transformAnimation(animation);\n        return res;\n    };\n    const tab = ['H', 'S', 'V', 'A'];\n    const colorOnStart = (animation, value, timestamp, previousAnimation) => {\n        let HSVAValue;\n        let HSVACurrent;\n        let HSVAToValue;\n        const res = [];\n        if (isColor(value)) {\n            HSVACurrent = convertToHSVA(animation.current);\n            HSVAValue = convertToHSVA(value);\n            if (animation.toValue) {\n                HSVAToValue = convertToHSVA(animation.toValue);\n            }\n        }\n        tab.forEach((i, index) => {\n            animation[i] = Object.assign({}, animationCopy);\n            animation[i].current = HSVACurrent[index];\n            animation[i].toValue = HSVAToValue ? HSVAToValue[index] : undefined;\n            animation[i].onStart(animation[i], HSVAValue[index], timestamp, previousAnimation ? previousAnimation[i] : undefined);\n            res.push(animation[i].current);\n        });\n        animation.current = toRGBA(res);\n    };\n    const colorOnFrame = (animation, timestamp) => {\n        const HSVACurrent = convertToHSVA(animation.current);\n        const res = [];\n        let finished = true;\n        tab.forEach((i, index) => {\n            animation[i].current = HSVACurrent[index];\n            finished &= animation[i].onFrame(animation[i], timestamp);\n            res.push(animation[i].current);\n        });\n        animation.current = toRGBA(res);\n        return finished;\n    };\n    animation.onStart = (animation, value, timestamp, previousAnimation) => {\n        if (isColor(value)) {\n            colorOnStart(animation, value, timestamp, previousAnimation);\n            animation.onFrame = colorOnFrame;\n            return;\n        }\n        else if (typeof value === 'string') {\n            prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n            animation.onFrame = prefNumberSuffOnFrame;\n            return;\n        }\n        baseOnStart(animation, value, timestamp, previousAnimation);\n    };\n}\nexport function defineAnimation(starting, factory) {\n    'worklet';\n    if (IN_STYLE_UPDATER) {\n        return starting;\n    }\n    const create = () => {\n        'worklet';\n        const animation = factory();\n        decorateAnimation(animation);\n        return animation;\n    };\n    if (_WORKLET || !NativeReanimated.native) {\n        return create();\n    }\n    return create;\n}\nexport function cancelAnimation(sharedValue) {\n    'worklet';\n    // setting the current value cancels the animation if one is currently running\n    sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign\n}\nexport function withTiming(toValue, userConfig, callback) {\n    'worklet';\n    return defineAnimation(toValue, () => {\n        'worklet';\n        const config = {\n            duration: 300,\n            easing: Easing.inOut(Easing.quad),\n        };\n        if (userConfig) {\n            Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n        }\n        function timing(animation, now) {\n            const { toValue, progress, startTime, current } = animation;\n            const runtime = now - startTime;\n            if (runtime >= config.duration) {\n                // reset startTime to avoid reusing finished animation config in `start` method\n                animation.startTime = 0;\n                animation.current = toValue;\n                return true;\n            }\n            const newProgress = config.easing(runtime / config.duration);\n            const dist = ((toValue - current) * (newProgress - progress)) / (1 - progress);\n            animation.current += dist;\n            animation.progress = newProgress;\n            return false;\n        }\n        function onStart(animation, value, now, previousAnimation) {\n            if (previousAnimation &&\n                previousAnimation.type === 'timing' &&\n                previousAnimation.toValue === toValue &&\n                previousAnimation.startTime) {\n                // to maintain continuity of timing animations we check if we are starting\n                // new timing over the old one with the same parameters. If so, we want\n                // to copy animation timeline properties\n                animation.startTime = previousAnimation.startTime;\n                animation.progress = previousAnimation.progress;\n            }\n            else {\n                animation.startTime = now;\n                animation.progress = 0;\n            }\n            animation.current = value;\n        }\n        return {\n            type: 'timing',\n            onFrame: timing,\n            onStart,\n            progress: 0,\n            toValue,\n            current: toValue,\n            callback,\n        };\n    });\n}\nexport function withSpring(toValue, userConfig, callback) {\n    'worklet';\n    return defineAnimation(toValue, () => {\n        'worklet';\n        // TODO: figure out why we can't use spread or Object.assign here\n        // when user config is \"frozen object\" we can't enumerate it (perhaps\n        // something is wrong with the object prototype).\n        const config = {\n            damping: 10,\n            mass: 1,\n            stiffness: 100,\n            overshootClamping: false,\n            restDisplacementThreshold: 0.01,\n            restSpeedThreshold: 2,\n        };\n        if (userConfig) {\n            Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n        }\n        function spring(animation, now) {\n            const { toValue, lastTimestamp, current, velocity } = animation;\n            const deltaTime = Math.min(now - lastTimestamp, 64);\n            animation.lastTimestamp = now;\n            const c = config.damping;\n            const m = config.mass;\n            const k = config.stiffness;\n            const v0 = -velocity;\n            const x0 = toValue - current;\n            const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio\n            const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)\n            const omega1 = omega0 * Math.sqrt(1 - Math.pow(zeta, 2)); // exponential decay\n            const t = deltaTime / 1000;\n            const sin1 = Math.sin(omega1 * t);\n            const cos1 = Math.cos(omega1 * t);\n            // under damped\n            const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n            const underDampedFrag1 = underDampedEnvelope *\n                (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n            const underDampedPosition = toValue - underDampedFrag1;\n            // This looks crazy -- it's actually just the derivative of the oscillation function\n            const underDampedVelocity = zeta * omega0 * underDampedFrag1 -\n                underDampedEnvelope *\n                    (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n            // critically damped\n            const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n            const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n            const criticallyDampedVelocity = criticallyDampedEnvelope *\n                (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n            const isOvershooting = () => {\n                if (config.overshootClamping && config.stiffness !== 0) {\n                    return current < toValue\n                        ? animation.current > toValue\n                        : animation.current < toValue;\n                }\n                else {\n                    return false;\n                }\n            };\n            const isVelocity = Math.abs(velocity) < config.restSpeedThreshold;\n            const isDisplacement = config.stiffness === 0 ||\n                Math.abs(toValue - current) < config.restDisplacementThreshold;\n            if (zeta < 1) {\n                animation.current = underDampedPosition;\n                animation.velocity = underDampedVelocity;\n            }\n            else {\n                animation.current = criticallyDampedPosition;\n                animation.velocity = criticallyDampedVelocity;\n            }\n            if (isOvershooting() || (isVelocity && isDisplacement)) {\n                if (config.stiffness !== 0) {\n                    animation.velocity = 0;\n                    animation.current = toValue;\n                }\n                return true;\n            }\n        }\n        function onStart(animation, value, now, previousAnimation) {\n            animation.current = value;\n            if (previousAnimation) {\n                animation.velocity =\n                    previousAnimation.velocity || animation.velocity || 0;\n                animation.lastTimestamp = previousAnimation.lastTimestamp || now;\n            }\n            else {\n                animation.lastTimestamp = now;\n            }\n        }\n        return {\n            onFrame: spring,\n            onStart,\n            toValue,\n            velocity: config.velocity || 0,\n            current: toValue,\n            callback,\n        };\n    });\n}\nexport function withDecay(userConfig, callback) {\n    'worklet';\n    return defineAnimation(0, () => {\n        'worklet';\n        const config = {\n            deceleration: 0.998,\n        };\n        if (userConfig) {\n            Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n        }\n        const VELOCITY_EPS = 5;\n        function decay(animation, now) {\n            const { lastTimestamp, initialVelocity, current, velocity } = animation;\n            const deltaTime = Math.min(now - lastTimestamp, 64);\n            animation.lastTimestamp = now;\n            const kv = Math.pow(config.deceleration, deltaTime);\n            const kx = (config.deceleration * (1 - kv)) / (1 - config.deceleration);\n            const v0 = velocity / 1000;\n            const v = v0 * kv * 1000;\n            const x = current + v0 * kx;\n            animation.current = x;\n            animation.velocity = v;\n            let toValueIsReached = null;\n            if (Array.isArray(config.clamp)) {\n                if (initialVelocity < 0 && animation.current <= config.clamp[0]) {\n                    toValueIsReached = config.clamp[0];\n                }\n                else if (initialVelocity > 0 &&\n                    animation.current >= config.clamp[1]) {\n                    toValueIsReached = config.clamp[1];\n                }\n            }\n            if (Math.abs(v) < VELOCITY_EPS || toValueIsReached !== null) {\n                if (toValueIsReached !== null) {\n                    animation.current = toValueIsReached;\n                }\n                return true;\n            }\n        }\n        function onStart(animation, value, now) {\n            animation.current = value;\n            animation.lastTimestamp = now;\n            animation.initialVelocity = config.velocity;\n        }\n        return {\n            onFrame: decay,\n            onStart,\n            velocity: config.velocity || 0,\n            callback,\n        };\n    });\n}\nexport function withDelay(delayMs, _nextAnimation) {\n    'worklet';\n    return defineAnimation(_nextAnimation, () => {\n        'worklet';\n        const nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n        function delay(animation, now) {\n            const { startTime, started, previousAnimation } = animation;\n            if (now - startTime > delayMs) {\n                if (!started) {\n                    nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);\n                    animation.previousAnimation = null;\n                    animation.started = true;\n                }\n                const finished = nextAnimation.onFrame(nextAnimation, now);\n                animation.current = nextAnimation.current;\n                return finished;\n            }\n            else if (previousAnimation) {\n                const finished = previousAnimation.onFrame(previousAnimation, now);\n                animation.current = previousAnimation.current;\n                if (finished) {\n                    animation.previousAnimation = null;\n                }\n            }\n            return false;\n        }\n        function onStart(animation, value, now, previousAnimation) {\n            animation.startTime = now;\n            animation.started = false;\n            animation.current = value;\n            animation.previousAnimation = previousAnimation;\n        }\n        const callback = (finished) => {\n            if (nextAnimation.callback) {\n                nextAnimation.callback(finished);\n            }\n        };\n        return {\n            isHigherOrder: true,\n            onFrame: delay,\n            onStart,\n            current: nextAnimation.current,\n            callback,\n        };\n    });\n}\nexport function withSequence(..._animations) {\n    'worklet';\n    return defineAnimation(_animations[0], () => {\n        'worklet';\n        const animations = _animations.map((a) => {\n            const result = typeof a === 'function' ? a() : a;\n            result.finished = false;\n            return result;\n        });\n        const firstAnimation = animations[0];\n        const callback = (finished) => {\n            if (finished) {\n                // we want to call the callback after every single animation\n                // not after all of them\n                return;\n            }\n            // this is going to be called only if sequence has been cancelled\n            animations.forEach((animation) => {\n                if (typeof animation.callback === 'function' && !animation.finished) {\n                    animation.callback(finished);\n                }\n            });\n        };\n        function sequence(animation, now) {\n            const currentAnim = animations[animation.animationIndex];\n            const finished = currentAnim.onFrame(currentAnim, now);\n            animation.current = currentAnim.current;\n            if (finished) {\n                // we want to call the callback after every single animation\n                if (currentAnim.callback) {\n                    currentAnim.callback(true /* finished */);\n                }\n                currentAnim.finished = true;\n                animation.animationIndex += 1;\n                if (animation.animationIndex < animations.length) {\n                    const nextAnim = animations[animation.animationIndex];\n                    nextAnim.onStart(nextAnim, currentAnim.current, now, currentAnim);\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n        function onStart(animation, value, now, previousAnimation) {\n            if (animations.length === 1) {\n                throw Error('withSequence() animation require more than one animation as argument');\n            }\n            animation.animationIndex = 0;\n            if (previousAnimation === undefined) {\n                previousAnimation = animations[animations.length - 1];\n            }\n            firstAnimation.onStart(firstAnimation, value, now, previousAnimation);\n        }\n        return {\n            isHigherOrder: true,\n            onFrame: sequence,\n            onStart,\n            animationIndex: 0,\n            current: firstAnimation.current,\n            callback,\n        };\n    });\n}\nexport function withRepeat(_nextAnimation, numberOfReps = 2, reverse = false, callback) {\n    'worklet';\n    return defineAnimation(_nextAnimation, () => {\n        'worklet';\n        const nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n        function repeat(animation, now) {\n            const finished = nextAnimation.onFrame(nextAnimation, now);\n            animation.current = nextAnimation.current;\n            if (finished) {\n                animation.reps += 1;\n                // call inner animation's callback on every repetition\n                // as the second argument the animation's current value is passed\n                if (nextAnimation.callback) {\n                    nextAnimation.callback(true /* finished */, animation.current);\n                }\n                if (numberOfReps > 0 && animation.reps >= numberOfReps) {\n                    return true;\n                }\n                const startValue = reverse\n                    ? nextAnimation.current\n                    : animation.startValue;\n                if (reverse) {\n                    nextAnimation.toValue = animation.startValue;\n                    animation.startValue = startValue;\n                }\n                nextAnimation.onStart(nextAnimation, startValue, now, nextAnimation.previousAnimation);\n                return false;\n            }\n            return false;\n        }\n        const repCallback = (finished) => {\n            if (callback) {\n                callback(finished);\n            }\n            // when cancelled call inner animation's callback\n            if (!finished && nextAnimation.callback) {\n                nextAnimation.callback(false /* finished */);\n            }\n        };\n        function onStart(animation, value, now, previousAnimation) {\n            animation.startValue = value;\n            animation.reps = 0;\n            nextAnimation.onStart(nextAnimation, value, now, previousAnimation);\n        }\n        return {\n            isHigherOrder: true,\n            onFrame: repeat,\n            onStart,\n            reps: 0,\n            current: nextAnimation.current,\n            callback: repCallback,\n        };\n    });\n}\n/* Deprecated section, kept for backward compatibility. Will be removed soon */\nexport function delay(delayMs, _nextAnimation) {\n    'worklet';\n    console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\n    return withDelay(delayMs, _nextAnimation);\n}\nexport function repeat(_nextAnimation, numberOfReps = 2, reverse = false, callback) {\n    'worklet';\n    console.warn('Method `repeat` is deprecated. Please use `withRepeat` instead');\n    return withRepeat(_nextAnimation, numberOfReps, reverse, callback);\n}\nexport function loop(nextAnimation, numberOfLoops = 1) {\n    'worklet';\n    console.warn('Method `loop` is deprecated. Please use `withRepeat` instead');\n    return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);\n}\nexport function sequence(..._animations) {\n    'worklet';\n    console.warn('Method `sequence` is deprecated. Please use `withSequence` instead');\n    return withSequence(..._animations);\n}\n/* Deprecated section end */\n"]},"metadata":{},"sourceType":"module"}